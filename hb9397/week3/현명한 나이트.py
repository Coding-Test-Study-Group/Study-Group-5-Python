# https://www.acmicpc.net/problem/18404
# # 풀이는 아래
from collections import deque

N, M = map(int, input().split())

go = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)]

pan = [[-1]*N for _ in range(N)]

startY, startX = map(int, input().split())

enemy = [list(map(int, input().split())) for _ in range(M)]

def bfs(y, x):
    temp = deque()
    temp.append((y, x))
    pan[y][x] = 0

    while temp:
        y, x = temp.popleft()

        for goY, goX in go:
            Y, X = y+goY, x+goX

            if (0 <= Y < N) and (0 <= X < N) and pan[Y][X] == -1:
                temp.append((Y, X))
                pan[Y][X] = pan[y][x]+1

bfs(startY-1, startX-1)

for y, x in enemy:
    print(pan[y-1][x-1], end=' ')
print()

#----------------------------------------------------------------------------------------------------------------------------------------------#
# 풀이
# bfs 를 이용해서 현재 위치를 시작값으로 받아서 현재 위치에서 탐색 가능한 모든 위치를 기억하는 동시에 탐색이 가능한 위치로 가기 위해 소모한 비용을 기억한뒤
# 다시 기억하고 있는 탐색 가능한 위치에서 탐색이 가능한 위치와 그 위치로 가기 위한 비용을 기억하게 하여 모든 좌표에 대해 적용한 뒤 
# 원하는 좌표로 가기 위해 소모한 비용을 도출한다.

from collections import deque

# N 은 N*N 크기의 체스판 크기를 나타내기 위한 수,
# M 은 나이트로 잡아야할 상대편의 말의 위치개수(나이트가 이동해야하는 칸의 개수)
N, M = map(int, input().split())

# 나이트가 이동할 수 있는 8가지 방향의 상대적인 위치를 담은 리스트입니다.
go = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)]

# 체스판을 표현한 이차원 배열로 초기값은 모두 -1을 갖게 하여 bfs를 수행하면서
# 각 칸까지의 최소 이동 수를 저장한다.
# 아래는 N이 4일 때 생성되는 체스판의 초기값 예시
# bfs 수행으로 -1 에는 해당되는 index(체스판 상에서의 좌표값)로 현재 위치에서 가는 최소 이동수 가 저장된다.
# [[-1, -1, -1, -1], [-1, -1, -1, -1], [-1, -1, -1, -1], [-1, -1, -1, -1]]
pan = [[-1]*N for _ in range(N)]

# 체스판에서의 나이트의 최초 위치
startY, startX = map(int, input().split())

# 입력줄에서 첫번째 줄에서는 체스판 크기를 위한 N, M은 잡아야할 말의 개수를 입력하고
# 두번째 줄에서는 나이트의 최초 위치를 입력하고 현재 줄의 코드에서는 두번째 입력값까지
# 모두 입력 받았으므로 이후 세번째 줄부터 M번째 줄의 모든 입력은 나이트로 잡아야하는 말의 좌표 M개에 해당된다.
enemy = [list(map(int, input().split())) for _ in range(M)]

# bfs 를 이용해서 현재 나이트의 위치 (y, x) 에서 체스판 내에서 이동 가능한 좌표를 모두 기억하고 그 곳으로 이동하기 위한 이동 횟수를 기록
# 그 다음 이동 가능한 좌표들 중에서 다시 위의 작업을 반복하도록 함수를 생성한다.

# 2차원 배열로 표현된 체스판 [[-1, -1, -1, -1], [-1, -1, -1, -1], [-1, -1, -1, -1], [-1, -1, -1, -1]]
# 의 좌표를 인데스로 접근할 때 첫번째 줄은 [0][x] 두번째 줄은 [1][x] 로 접근해야 하므로 y축의 값이 앞으로 x축의 값이 뒤로 가게 설정
def bfs(y, x):
    temp = deque()
    # 현재 나이트의 좌표 값 삽입
    temp.append((y, x))

    # 나이트의 시작 위치는 이동할 필요가 없으므로 0에 해당된다.
    pan[y][x] = 0

    # temp 가 빌 때까지 반복
    while temp:
        # 현재 좌표의 가장 앞 요소를 pop 하여 y좌표, x좌표를 가지고
        y, x = temp.popleft()
        # go(현재 위치에서 나이트가 이동 가능한 좌표로 갈 수 있는 x와 y 좌표에 대한 연산)
        # 에 대해 순회하면서
        for goY, goX in go:
            # 현재 나이트의 위치에서 go 에 저장된 좌표로 이동 시켜보고
            Y, X = y+goY, x+goX
            # 이동한 각각의 Y, X 좌표가 체스판 내에 존재하고 처음 방문할 때만 현재 나이트의 위치에서 이동할 수 있는 모든 좌표를 기록하고 기록된 좌표들에 가기위해서
            # 현재 위치부터 이동가능한 좌표로 이동한 횟수를 기억한다.
            # 이렇게 되면 현재 경우에 방문이 가능한 모든 좌표는 모두 최소로 이동한 횟수가 된다.
            if (0 <= Y < N) and (0 <= X < N) and pan[Y][X] == -1:
                # temp 에 이동한 나이트의 현재 좌표를 삽입 -> 나이트가 이동한 것.
                temp.append((Y, X))
                # 직전의 나이트가 이동한 좌표까지 이동한 횟수에
                # 현재 나이트의 좌표를 한 번더 이동 시켰으므로 +1 해서 현재 나이트의 위치까지 오기 위해서 이동한 횟수를 기록한다.
                pan[Y][X] = pan[y][x]+1

# 나이트의 최초위치의 좌표값을 매개변수로 bfs 함수호출
bfs(startY-1, startX-1)

# enemy(잡아야할 상대방의 말의 모든 좌표) 의 좌표 위치의 y, x 에 대해서 나이트가 이동한 횟수를 반환
for y, x in enemy:
    print(pan[y-1][x-1], end=' ')
print()